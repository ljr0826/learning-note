# api篇

## geolocation获取地理信息位置

获取地理信息位置方法：GPS最快--其次网络

GPS（什么样的设备上有GPS？台式机几乎都没有GPS，笔记本绝大多数没有，智能手机绝大多数都有

没有GPS的情况下，通过网络可以实现定位（粗略的估计地理位置）

怎么调用html5的功能进行定位？

window.navigator.geolocation.getCurrentPosition(function(position){console.log(position)})

h5网页本身没有获取地理位置的能力，要依靠浏览器（要求是https协议下，或file协议）

地理位置算是个人的私人信息，所以用https协议才可以获取到这个信息，file协议也可以；http协议下是不能获取的

```js
window.navigator.geolocation.getCurrentPosition(
  function (position) {
    console.log("========");
    console.log(position); //该对象中有属性coords
    //coords中有属性latitude表示纬度、longitude表示经度（能够大于90°）
    //accuracy表示经度的准确度，剩余属性都不太常用，没有人用页面来获取地理位置信息
    //客户端本身就有很多用来获取信息的方法，很少用h5来获取
    //经度的最大值是180°，纬度只分北纬和南纬最大90°
  },
  function () {
    console.log("++++++++++");
  }
);
```

## 四行写个服务器

后续的知识希望可以使用手机来访问电脑来学习，所以需要开一个服务器（用手机连接电脑）

node.js的知识前端虽然目前不要求精通，但是要会写，多查mdn

```js
var express = require("express"); //node.js的内容

var app = new express();

app.use(express.static("./page"));
app.get("/getHtml", (req, res) => {
  res.sendFile(__dirname + "/index.html");
});

app.listen(12306); //端口号尽量大于8000。或者等于80(启动的时候不需要输入端口号。web服务默认的端口就是80)
//express默认访问index.html
//webstorm 右键 run server.js
//命令框或者vscode的客户端 进入到项目路径里 然后node server.js
```

## deviceorientation体感事件

device设备  orientation指向

deviceorientation是一个事件（可以用来做指南针）

```js
//手机有个陀螺仪来判断东西南北朝向
//只有带有陀螺仪的设备才能支持体感事件
//苹果设备只有在https协议的情况下才能使用这些接口，老版本可以支持
window.addEventListener("deviceorientation", function (e) {
  // console.log(e);
  //属性alpha：指北（指南针），[0,360)当为0的时候指北，180指南
  //属性beta：平放的时候值为0，如果将手机立起来（短边接触桌面，直立的时候）值为90
  //属性gamma：平放的时候值为0，如果将手机立起来（长边接触桌面），值为90
  document.querySelector(
    ".main"
  ).innerHTML = `alpha: ${e.alpha}<br>beta:${e.beta}<br>gamma:${e.gamma}`;
}); //体感事件
```

## 手机怎么访问电脑？

1. 手机要和电脑在同一个局域网下
2. 获取电脑的IP地址（方法：windows+R运行，输入cmd，输入ipconfig查找无线局域网
3. 在手机上输入相应的ip和端口进行访问

## devicemotion设备定位事件

可以用来做摇一摇

```js
window.addEventListener("devicemotion", function (e) {
  console.log(e);
  //acceleration表示加速度。分为x、y、z三个方向
  document.querySelector(
    ".main"
  ).innerHTML = `x--${e.acceleration.x}<br>y--${e.acceleration.y}<br>z--${e.acceleration.z}`;
  if (
    Math.abs(e.acceleration.x) > 9 ||
    Math.abs(e.acceleration.y) > 9 ||
    Math.abs(e.acceleration.z) > 9
  ) {
    alert("在摇晃");
  }
});
```

## requestAnimationFrame

告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行（兼容性极差）

屏幕刷新的频率是60HZ即每秒60次，如果变化1秒超过60次，必然会有一些动画帧会被丢掉

timer = requestAnimationFrame(callback)兼容性极差

cancelAnimationFrame(timer)取消

```js
var timer = null;
function move() {
  var square = document.querySelector(".main");
  if (square.offsetLeft > 700) {
    cancelAnimationFrame(timer); //取消
  }
  square.style.left = square.offsetLeft + 20 + "px";
  timer = requestAnimationFrame(move); //h5帮助我们做的一个优化
  //因为requestAnimationFrame是每秒60帧，有一个特殊的队列，可以准时执行每一帧
}
// setInterval(move, 1000 / 60); //计时器也设置成这样，每一帧的时间要小于1/60，上一帧没有执行完是绝对不会执行下一帧的
move();
```

## localStorage（见本地化存储）

localStorage是在浏览器里存储东西的，一般浏览器里存储东西使用cookie

cookie存储状态，会被http协议携带发送到服务器，影响网络请求的开销

localStorage只能存储字符串。所以如果存储数组或对象的话，使用JSON.stringify()

长期存放在浏览器里，使用localStorage。

sessionStorage只在会话期有效，页面关闭即没用了

localStorage对比cookie
1. localStorage在发送请求时不会把数据发出去，cookie会跟随http协议
2. cookie存储的内容大小限制4k左右，llocalstorage可以存5M左右
3. 都不能跨域

## history

主要用在什么地方？
- a页面跳转到b页面再跳转到c页面，为了网页的性能，经常会有单页面操作

- history：用来表示历史记录，即之前访问过哪些记录（为避免侵犯隐私，只能获取到当前网站的历史记录的简单信息）！
    - go 方法。技能前进也能后退，参数为正数即前进几个页面，负数即后退几个页面
    - back 方法。后退
    - forward 方法。前进。这三个方法可以让浏览器前进或后退
    - history.pushState({inpVal:value},null,url)三个参数分别表示：当前页面的状态,title,url地址。
    - popstate事件。即只要url变了就会触发
    - hashchange事件。当URL的片段标识符更改时，将触发hashchange事件 (跟在＃符号后面的URL部分，包括＃符号)。即锚点变化触发

当活动历史记录条目更改时，将触发popstate事件。如果被激活的历史记录条目是通过对history.pushState（）的调用创建的，或者受到对history.replaceState（）的调用的影响，popstate事件的state属性包含历史条目的状态对象的副本。

需要注意的是调用history.pushState()或history.replaceState()不会触发popstate事件。只有在做出浏览器动作时，才会触发该事件，如用户点击浏览器的回退按钮（或者在Javascript代码中调用history.back()或者history.forward()方法）

不同的浏览器在加载页面时处理popstate事件的形式存在差异。页面加载时Chrome和Safari通常会触发(emit )popstate事件，但Firefox则不会

history.pushState() 方法向当前浏览器会话的历史堆栈中添加一个状态（state）。

## worker

worker是一个新的接口，h5由于兼容性的原因没有几个常用的

js都是单线程的，但是自从出了worker之后就变了

worker是真的多线程，不是伪多线程（类似于ajax回调）

worker不能操作dom，没有window对象，不能读取文件。可以发ajax，可以计算

找文档把。new Worker()、message事件、postMessage方法

在worker中能否继续创建worker？
- 理论上是可以的，但是没有任何一个浏览器支持他

window.postMessage()方法可以安全的实现跨源通信