# 普通符号

符号分为很多种，有普通符号、共享符号、知名符号。都差不多，统称为符号。本节课先学习普通符号

符号到底是什么？英文symbol，是 ES6 新增的一个数据类型，（以前的数据类型不够用了，所以es6新增了一个新的数据类型

符号是通过使用函数调用`Symbol(符号描述)`来创建（仅此一种创建方式，描述信息只起到一个调试的作用）

```js
//创建一个符号
//先学习符号的语法，然后学习它的用途
const symbol1 = Symbol();//符号只有调用Symbol函数这一种创建方式
const symbol2 = Symbol("abc"); //参数是对于符号的描述。描述信息只是起到一个调试的作用（会把描述信息转化为字符串输出）
console.log(symbol1,symbol2);//true
console.log(typeof symbol1)//'symbol' 
console.log(symbol1===symbol2)//false 每次调用Symbol函数得到的符号永远是唯一的
console.log("string", 123, true, undefined, null, function () {}); //在控制台可以看出符号是一种新的数据类型
```

符号设计的初衷，是为了**给对象设置私有属性**
  - （有一些属性，只能在对象内部的方法里面可以用，别的对象用不了）
  - （很多的面向对象的语言里面，都有各自的私有属性的表达方式。但es6之前js里面没有）

私有属性：只能在对象内部使用，外面无法使用。es6里面学习的类同样有这种需求

```js
const hero = {
  attack: 30,
  hp: 300,
  defence: 10,
  gongji() {//攻击函数
    //伤害：攻击力*随机数(0.8~1.1)
    const dmg = this.attack * this.getRandom(0.8, 1.1);
    console.log(dmg);
  },
  getRandom(min, max) {//根据最大值和最小值产生一个随机数
    return Math.random() * (max - min) + min;
  }, //这个函数作为辅助函数。为了内部实现而出现的，不希望外部使用（比如，买一个微波炉，用户使用越方便越好，暴露太多的方法没有意义）
  //但是以前js做不到私有属性的实现，所以他写的所有东西都要暴漏出去，一些第三方库的属性就是在属性名上加上一些标记，不让外面用到
  //若将这个getRandom方法写在gongji方法里面：1.每次调用攻击方法都会定义一个函数 2.英雄里面别的方法想用这个功能却无法共享
  //es6私有属性由此而来
}

class Hero {
  constructor(attack, hp, defence) {
    this.attack = attack;
    this.hp = hp;
    this.defence = defence;
  }
  gongji() {
    const dmg = this.attack * this.getRandom(0.8, 1.1);
    console.log(dmg);
  }
  getRandom(min, max) {
    return Math.random() * (max - min) + min;
  } //若这个方法里面用到this里面的属性，放到外面也不合适
}
```

符号具有以下特点：
- 没有字面量。（123，"fsd"，null，undefined，{}，等等）
- 使用 typeof 得到的类型是 symbol
- **每次调用 symbol 函数得到的符号永远不相等，无论符号名是否相同**
- 符号可以作为对象的属性名存在，这种属性称之为符号属性（以前对象的属性名一定是一个字符串：现在由于多了一个符号，es6规定对象的属性名除了字符串意外还可以是符号类型。若属性的名字是一个符号类型，该属性就叫做符号属性）
  - 于是。开发者可以通过精心的设计，让这些属性无法通过常规方式被外界访问
  - 符号属性是不能枚举的。因此在 for-in 循环中无法读取到符号属性，Object.keys 方法也无法读取到符号属性(就是为了隐藏符号属性)
  - Object.getOwnPropertyNames 尽管可以得到所有无法枚举的属性，但是仍然无法读取到符号属性
  - ES6 新增 Object.getOwnPropertySymbols 方法，可以读取符号属性

    > ES6 规定：对象的属性名一定除了字符串以外还可能是符号属性

```js
const syb1 = Symbol("这是用于对象的一个属性");
const obj = {
  a: 1,
  b: 2,
  [syb1]: 3, //符号属性，需要使用可计算的属性名来将符号的值作为属性名。
};
console.log(obj);

const hero = (function () {
  const getRandom = Symbol("用于产生随机数的符号"); //这是一个局部变量。函数外无法使用
  return {
    attack: 30,
    hp: 300,
    defence: 10,
    gongji() {
      //攻击函数
      //伤害：攻击力*随机数(0.8~1.1)
      const dmg = this.attack * this[getRandom](0.8, 1.1);
      console.log(dmg);
    },
    [getRandom](min, max) {
      //根据最大值和最小值产生一个随机数
      return Math.random() * (max - min) + min;
    }, //即希望将getRandom方法变成一个私有的属性。怎么做？用普通属性外面一定能访问
    //由于符号是唯一的，永远无法产生一个同样的符号：写一个立即执行函数，返回一个对象
  };
})();
hero.gongji();
console.log(hero); //可以看到符号属性，但是无法调用
// hero[getRandom](3, 5); //会报错。函数外部无法使用函数内部的局部变量
//即以上实现了对象的属性私有化

const Hero = (() => {
  const getRandom = Symbol("符号属性");
  return class Hero {
    constructor(attack, hp, defence) {
      this.attack = attack;
      this.hp = hp;
      this.defence = defence;
    }
    gongji() {
      const dmg = this.attack * this[getRandom](0.8, 1.1);
      console.log(dmg);
    }
    [getRandom](min, max) {
      return Math.random() * (max - min) + min;
    } //若这个方法里面用到this里面的属性，放到外面也不合适
  };
})();
const h = new Hero(3, 6, 3);
const sybs = Object.getOwnPropertySymbols(Hero.prototype);
console.log(h[sybs[0]]); //以后学了模块化，有更简单的方法，现在只能用立即执行函数将其包裹在里面形成局部变量
```

- 符号无法被隐式转换，因此不能被用于数学运算、字符串拼接或其他隐式转换的场景，但符号可以显式的转换为字符串(做一些信息输出)，通过 String 构造函数手动进行转换即可，console.log 之所以可以输出符号，是它在内部进行了显示转换

```js
const syb = Symbol();
const obj = {
  [syb]: 1,
  a: 2,
  b: 3,
};
for (const prop in obj) {
  console.log(prop);
}
console.log(Object.keys(obj));
console.log(Object.getOwnPropertyNames(obj)); //即几乎是没有什么方法能够获取到符号属性的
const sybs = Object.getOwnPropertySymbols(obj); //得到符号属性形成的数组
console.log(sybs, sybs[0] === syb); //  true


const syb = Symbol();
console.log(String(syb), typeof String(syb)); //Symbol() string
```
