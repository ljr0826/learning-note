# 知名(公共、具名)符号

后面要学习一个非常重要的知名符号，只不过它要配合其他知识使用

知名符号是具有一些特殊含义的共享符号（早就创建好了，不需要再创建），通过 Symbol 的静态属性得到知名符号

ES6 延续了 ES5 的思想：**尽量的为js语言减少魔法（即搞不清楚一个东西是怎么实现的，无法参与它的内部实现），暴露内部实现！**

因此，ES6 通过知名符号暴露了某些场景的内部实现

以后学习vue、react，他们最大的区别就是vue里面有很多魔法，参与它的改动很麻烦；而react没有魔法

1. Symbol.hasInstance（是函数上的原型方法，即Function.prototype上的方法）

该符号用于定义构造函数的静态成员，它将影响 instanceof 的判定

> 现在，在某些场景中，我们可以参与js的内部实现

```js
obj instanceof A; //对象obj的__proto__上面有没有A的原型，或者说函数A的原型是否在对象obj的原型链上
//等效于
A[Symbol.hasInstance](obj);//这个方法实质上在Function.prototype[Symbol.hasInstance]上，所有函数都有这个属性
//以前instanceof这个关键字就是判断原型链的，我们无法参与他的底层实现
```

```js
function A() {}
//希望改动这个方法，让instance永远是false。但是A[Symbol.hasInstance]这个属性是不能被改写的
Object.defineProperty(A, Symbol.hasInstance, {
  value: function (obj) {
    return false;
  },
});
const obj = new A();
console.log(obj instanceof A); //true--->false
console.log(A[Symbol.hasInstance](obj)); //true--->false
```

2. [扩展] Symbol.isConcatSpreadable

该知名符号会影响数组的 concat 方法

```js
const arr = [3];
const arr2 = [5, 6, 7, 8];
// arr2[Symbol.isConcatSpreadable] = false; //表示是否在数组连接时分割，设置为false则不分割了
const result = arr.concat(56, arr2);
console.log(result); //[3,56,[5,6,7,8]]还是[3,56,5,6,7,8]。答案是后者
//我们把这种处理方式叫做分割。
//即只要发现某个参数有数字索引并且有length属性，就会把这个参数当作数组来分割，分割完了之后加到新数组里面去
//以前没有办法控制这种行为，现在可以了
```

```js
//牛逼：可以分割对象
const arr = [1];
const obj = {
  0: 3,
  1: 4,
  length: 2,
  [Symbol.isConcatSpreadable]: true,
};
const result = arr.concat(2, obj);
console.log(result); //[1,2,3,4]
```

3. [扩展] Symbol.toPrimitive

该知名符号会影响类型转换的结果

```js
//有些对象会参与运算，参与运算时会进行一些转换
const obj = {
  a: 1,
  b: 2,
};
obj[Symbol.toPrimitive] = function () {
  return 2;
};
console.log(obj.valueOf().toString()); //对象参与运算时，会先调用valueOf再调用toString，直到转化为原始类型
console.log(obj + 123); //[object Object]--->125
console.log(obj * 123); //NaN--->246
```

```js
class Temperature {
  constructor(degree) {
    this.degree = degree;
  }
  [Symbol.toPrimitive](type) {
    // console.log(type);
    if (type === "default") {
      return this.degree + "摄氏度";
    } else if (type === "number") {
      return this.degree;
    } else if (type === "string") {
      return this.degree + "℃";
    }
  }
}
const t = new Temperature(30);
console.log(t.valueOf().toString());
console.log(t + "!"); //30摄氏度!
console.log(t / 2); //15
console.log(String(t)); //30℃
```

4. [扩展] Symbol.toStringTag

该知名符号会影响 Object.prototype.toString 的返回值

```js
class Person {
  [Symbol.toStringTag] = "Person"; //可以影响Object原生的toString函数
}
const p = new Person();
const arr = [23, 1, 646];
console.log(Object.prototype.toString.apply(p)); //[object Object]--->[object Person]
console.log(Object.prototype.toString.apply(arr)); //[object Array]
```

5. 其他知名符号

现在讲不了，需要结合一些后面的知识
