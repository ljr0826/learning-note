# 基本使用

> 请求测试地址：http://101.132.72.36:5100/api/local

调用`fetch`函数即可立即向服务器发送网络请求

这节课基本上已经能够覆盖大部分异步场景了

## 参数

该函数有两个参数需要传递：

1. 必填，字符串，请求地址

2. 选填，是一个对象，请求配置(如果有需要配置的就使用相关配置信息，否则使用默认值)

### 请求配置对象

常用：
- method：字符串，请求方法，默认值 GET(常用)
- headers：对象，请求头信息(常用)
- body：请求体的内容，必须匹配请求头中的 Content-Type(常用,get 请求数据放在url地址里；post 放在请求体中)

不常用：
- mode：字符串，请求模式
  - cors：默认值，配置为该值，会在请求头中加入 origin 和 referer。主要是用来解决跨域问题，表示允许跨域
  - no-cors：配置为该值，不会在请求头中加入 origin 和 referer，跨域的时候可能会出现问题
  - same-origin：指示请求必须在同一个域中发生，如果请求其他域，则会报错
- credentials：如何携带凭据(cookie)
  - omit：默认值，不携带 cookie
  - same-origin：请求同源地址时携带 cookie
  - includes：请求任何地址都携带 cookie。跨域请求一般就是用这个（但是在前端的大环境下，cookie几乎已经不用了）
- cache：配置浏览器的缓存模式
  - default：表示 fetch 请求之前将检查下 http 的缓存（检查一下目前有没有缓存，有就用，没有就重新发送请求更新缓存）
  - no-store：表示 fetch 请求将完全忽略 http 缓存的存在，这意味着请求之前将不再检查下 http 的缓存，拿到响应后，它也不会更新 http 缓存（忽略缓存，不管有没有缓存都重新请求，并且拿到新的数据后不更新缓存）
  - no-cache：如果存在缓存，那么 fetch 将发送一个条件查询 request 和一个正常的 request，拿到响应后，它会更新 http 缓存（不管有没有缓存都重新请求，但是拿到新的数据后更新缓存）
  - reload：表示 fetch 请求不顾一切的依赖缓存，即使缓存过期了，它依然从缓存中读取，除非没有任何缓存，那么它将发送一个正常的 request（和no-cache差不多。no-cache之前有缓存的话才会更新缓存，reload不管之前有没有都会更新缓存）
  - force-cache：表示 fetch 请求不顾一切的依赖缓存，即使缓存过期了，他依然从缓存中读取，除非没有任何缓存，那么它将发送一个正常的 request（不管缓存是否过期，都是用缓存。之前没有缓存才会发送请求）
  - only-if-cached：表示 fetch 请求不顾一切的依赖缓存，即使缓存过期了，它依然从缓存中读取。如果没有缓存，它将抛出网络错误(该设置只在 mode 为"same-origin"时有效)（不管缓存是否过期，都是用缓存。之前没有缓存会报错）

## 返回值(是重点)

fetch 函数返回一个 Promise 对象

- 当收到服务器的返回结果后，Promise 进入 resolved 状态，状态数据为 Response 对象(下面详细讲)
- 当网络发生错误(或其他导致无法完成交互的错误)时，Promise 进入 rejected 状态，状态数据为错误信息。

```js
function getProvinces() {
  const url = "http://101.132.72.36:5100/api/local"; //请求地址
  const config = {
    method: "GET", //请求方法
    headers: {
      "Content-Type": "application-json",
      a: 1, //也可以配置一些自定义的东西
    }, //请求头配置
    // body: "{'a':1}",
  }; //配置对象
  fetch(url, config).then(
    (resp) => {
      console.log(resp); //服务器的响应对象。服务器只要有响应就是resolve的状态
    },
    (err) => {
      console.log(err); //网络请求发生问题。有报错才reject
    }
  );
}
document.querySelector("button").onclick = getProvinces;

      async function getProvinces() {
        const url = "http://101.132.72.36:5100/api/local"; //请求地址
        const config = {
          method: "GET", //请求方法
          headers: {
            "Content-Type": "application-json",
            a: 1, //也可以配置一些自定义的东西
          }, //请求头配置
          // body: "{'a':1}",
        }; //配置对象
        try {
          const resp = await fetch(url, config);
          const result = await resp.text();
          console.log(result);//将消息体的信息解析成字符串
        } catch (err) {
          console.log(err);
        }
      }
      document.querySelector("button").onclick = getProvinces;
```

### Response 对象

- ok：boolean，当响应消息码在 200~299 之间时为 true，其他为 false(http协议的内容)
  - 即想要判断服务器返回给你的是不是一个正常的结果，应该查看这个属性，而不是fetch返回的promise对象的reject状态

- status：number，响应的状态码

以下方法辅助我们解析消息体的内容  

- text()：用于处理文本格式的 Ajax 响应。它从响应中获取文本流，将其读完，然后返回一个被解析为 string 对象的 Promise(常用)
  - 适用于服务器返回的是一个文本
  - 该方法返回的是一个promise对象
  - 将消息体的信息解析成字符串。需要一个过程，所以等一会才能出现结果

- blob()：用于处理二进制文本格式(比如图片获知电子表格)的 ajax 响应。它读取文件的原始数据，一旦读取完整个文件，就返回一个被解决为 blob 对象的 Promise

- json()：用于处理 json 格式的 ajax 响应，它将 json 数据流转换为一个被解决为 javascript 对象的 promise(常用)
  - 适用于服务器返回的是一个json格式的消息

- redirect()：可以用于重定向到另一个 URL。它会创建一个新的 Promise，以解决来自重定向的 URL 的响应
  - 用于重定向的。重新请求另外一个地址

text方法和json方法使用最多
