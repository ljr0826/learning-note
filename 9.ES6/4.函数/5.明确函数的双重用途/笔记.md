# 明确函数的双重用途

ES6出来之后主要是解决过去的一些老问题

ES6 提供了一个特殊的 API，可以使用该 API 在函数内部，判断该函数是否使用了 new 来调用

js函数原本就有两种用法，但是可能会乱用

**对象 instanceof 函数**：这是一个语法。而非方法：判断函数的原型是否在对象的原型链上(即对象是否是new 函数创建出来的)

```js
new.target;
//该表达式，得到的是：如果没有使用new来调用函数，则返回undefined
//如果使用new调用函数，则得到的是new关键字后面的函数本身
```

```js
function Person(firstName, lastName) {
  //判断是否是使用new 的方式调用
  // //过去的判断方式
  // if (!(this instanceof Person)) {
  //   throw new Error("该函数没有使用new来调用");
  // }
  if (new.target === undefined) {
    throw new Error("该函数没有使用new来调用");
  }
  console.log(new.target);
  this.firstName = firstName;
  this.lastName = lastName;
  this.fullName = `${firstName} ${lastName}`;
}
const person1 = new Person("顾", "昀");
// console.log(person1);
const person2 = Person("长", "庚"); //this指向window。和预计不符
// console.log(person2);
const person3 = Person.call(person1, "沈", "易");
// console.log(person3);
```
