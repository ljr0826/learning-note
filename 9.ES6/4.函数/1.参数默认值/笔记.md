# 参数默认值

## 使用

在书写形参时直接给形参赋值，赋的值即为默认值。

这样一来，当调用函数时，如果没有给对应的参数赋值(给他的值是 undefined),则会自动使用默认值

```js
//希望形参没有值的话给一个默认值
function sum(a, b = 1, c = 2) {
  // b = b === undefined && 1; //一定是undefined，null在数学运算中会转换为0
  // c = c === undefined && 2;
  return a + b + c;
}
console.log(sum(10, 1, 2));
console.log(sum(11, 1, 2));

//创建一个元素：name元素名称、container元素的父元素、content元素的内容
//对应实参没有值则会使用默认值
function createElement(
  name = "div",
  container = document.getElementById("demo"),
  content = ""
) {
  const ele = document.createElement(name);
  content && (ele.innerHTML = content);
  container.appendChild(ele);
}
createElement(undefined, undefined, "参数默认值");
```

## 【扩展】对 arguments 的影响

严格模式"use strict"下，arguments 和形参是脱离的（非严格模式不脱离）

只要给函数加上参数默认值，该函数会自动变成变量严格模式下的规则：arguments 和形参脱离

```js
//非严格模式下，形参和实参形成映射关系
"use strict"//严格模式下，形参和实参脱离不再映射。即函数内部第四行输出结果变成1 2
//只要给函数加上参数默认值。形参实参脱离。arguments以后不要再用了，不好（下节课讲更好的知识点）
function test(a, b=1) {
  console.log("arguments：", arguments[0], arguments[1]);//1 2
  console.log("a：", a, "。b：", b);//1 2
  a = 3;
  console.log("arguments：", arguments[0], arguments[1]);//3 2
  console.log("a：", a, "。b：", b);//3 2
}
test(1, 2);

      function test(a, b = 1) {
        //已经自动转化为严格模式。形参和实参脱离
        console.log("arguments：", arguments[0], arguments[1]); //1 2
        console.log("a：", a, "。b：", b); // 1 2
        b = 3;
        console.log("arguments：", arguments[0], arguments[1]); //1 2
        console.log("a：", a, "。b：", b); //1 3
      }
      test(1, 2);
```

## 【扩展】留意暂时性死区

形参和 ES6 中的 let 和 const 声明一样，具有作用域，并且根据参数的声明顺序，存在暂时性死区

```js
function test(a, b = a) {
  console.log(a, b);
}
test(1, 2); // 1 2
test(1); // 1 1

function cc(a = b, b) {
  //形参解释：形参a=b，b存在于暂时性死区；走到b时将其从暂时性死区移除
  //即读取到a=b时就会报错，Uncaught ReferenceError: Cannot access 'b' before initialization at cc...
  let a = 33; //这样也不行。因为let或const不能重复声明
  console.log(a, b);
}
cc(undefined, 2);
```
