# 更好的 unicode 支持

```js
const text = "吉";
console.log("字符串长度:", text.length);
console.log("使用正则表达式测试:", /^.$/u.test(text));
//涉及到文字编码，是一个很深的知识。本节课简单了解一下
// ES6 为正则表达式添加了一个 flag： u，若添加了该配置，则匹配时使用码点匹配
```

早期，由于储存空间宝贵，unicode 使用 16 位二进制来存储文字。我们将一个 16 位的二进制编码叫做一个码元(code unit)

后来，由于技术的发展，unicode 对文字编码进行了扩展（空间不再那么宝贵），将某些文字扩展到了 32 位(占用两个码元，即从```2**16```拓展到了```2**32```)，并且将某个文字对应的二进制数字叫做码点(code point)。码元是最小单位

字符串长度是根据码元来取的，而不是码点。但实际上一个文字可能有一个或两个码元

ES6 为了解决这个困扰，为字符串提供了新方法（为了兼容旧的系统没有改动之前的方法）：```str.codePointAt(索引)```,根据字符串码元的位置得到码点

得到字符串码元的方法```str.charCodeAt(索引)```

同时 ES6 为正则表达式添加了一个 flag： u，若添加了该配置，则匹配时使用码点匹配。默认都是匹配码元

```js
//判断字符串char是32位还是16位
function is32bit(char, i) {
  //如果码点大于了16位二进制的最大值，则其是32位的
  return char.codePointAt(i) > 0xffff;
}
console.log("吉是否是32位的：", is32bit(text));
```

```js
//得到一个字符串码点的真实长度
function getLengthOfCodePoint(str) {
  let len = 0;
  for (let i = 0; i < str.length; i++) {
    //i在索引码元
    if (is32bit(str, i)) {
      //当前字符串在i这个位置，占用了两个码元
      i++;
    }
    len++;
  }
  return len;
}
console.log(getLengthOfCodePoint("ab即吉c"));
```
