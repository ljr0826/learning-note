# 生成器(Generator)

生成器是本章非常重要的知识，这部分知识严重依赖迭代器，算是es6里面很难的知识。慢慢消化

生成器在特定的场景使用很流畅。比如react，目前前端没有大规模的应用。但是它特殊的函数处理方式哪天说不定就火了

生成器的出现，最初是为了帮助你更加方便的写迭代器和迭代器创建函数。发现好用之后新增的特别的功能

1. 什么是生成器？

生成器是一个通过构造函数 Genertor 创建（只能js引擎内部使用，我们是无法创建的）的对象，生成器既是一个迭代器，同时又是一个可迭代对象
  - 所以生成器一定有next方法，并且一定有Symbol.iterator属性。生成器一定能使用for-of循环
  - 怎么创建生成器呢？

2. 如何创建生成器？

生成器的创建必须使用生成器函数(Genertor Function)。因为我们使用不了构造函数Generator

3. 如何书写一个生成器函数呢？---只需要在函数的function关键字后面或者函数的名称前面加上一个*，就是一个生成器函数

```js
//这是一个生成器函数，该函数一定返回一个生成器
function *method() {}
function* method(){}
async function* cc(){}//不能这样写。要么是生成器函数，要么是异步函数。不能两个都加
```

4. 生成器函数内部是如何执行的？

生成器函数内部是为了给生成器每一次迭代提供数据的

每次调用生成器的 next 方法，将导致生成器函数运行到下一个 yield 关键字位置

yield 是一个关键字，该关键字只能在生成器函数内部使用，表示表达"产生"一个迭代数据的意思。

```js
function* test() {
  //注意：这是一个生成器函数，调用这个函数只是简单的得到一个生成器而已。生成器函数的函数体根本就没有运行
  //这个生成器函数的作用是给生成器提供迭代数据的。生成器的初衷就是为了简化迭代器的编写
  //所以生成器函数内部是为了给生成器每次迭代提供数据。故而没有迭代时函数体不运行
  //每次调用生成器的next方法，将导致生成器函数运行到下一个yield关键字位置。
  //该yield关键字只能在生成器函数内部使用，表达产生一个迭代数据的意思
  console.log("第一次运行"); //这个生成器函数的函数体根本就没有运行
  yield 1; //表示产生了一个迭代数据1
  console.log("第二次运行");
  yield 2;
  console.log("第三次运行"); //函数体运行完。done属性变为true迭代完成
  return 10;//生成器的返回值出现在第一次done位true的value属性中
}
const generator = test(); //调用生成器函数一定会得到一个生成器对象。这是创建生成器对象的唯一途径
console.log(generator.next());
//感觉上，生成器在外面控制着函数的执行；实际上，就是一个语法糖，让你在函数内部方便的产生迭代数据

//见test2.html和test3.html
```

5. 有哪些需要注意的细节？

1). 生成器函数可以有返回值，返回值出现在第一次 done 为 true (即迭代刚结束)的 value 属性中
2). 调用生成器的 next 方法时，可以传递参数，传递的参数会交给 yield 表达式的返回值（好神奇，是生成器特有的东西）
3). 第一次调用 next 方法时，传参没有任何意义
4). 在生成器函数内部可以调用其他生成器函数，但是要注意加上`*`号(深入函数内部去迭代)

```js
function* test() {
  conosle.log("函数开始");
  let info = yield 1; //生成器第二次调用next方法。相当于将5传递给info即yield表达式的返回值
  console.log(info);
  info = yield 2 + info; //生成器第三次调用next方法。相当于将undefined传递给info
  console.log(info);
}
const generator = test();
generator.next(); //第一个调用next方法时传参没有任何意义。因为最开始连yield都没有
generator.next(5); //value值为7
generator.next(); //value值为undefiend
```

```js
function* t1() {
  yield "A";
  yield "B";
}
function* test() {
  //在生成器内部调用t1的方式
  // t1(); //这种调用方式错误。只是创建一个生成器对象，既没有迭代也没有赋值
  // yield t1(); //这种调用方式也是错误的。这次第一次迭代的结果即value值是函数t1调用生成的生成器对象
  yield* t1(); //我们希望在这个生成器函数的迭代过程中去使用其他函数的迭代过程。加个*过后就相当于将这个代码copy过来了
  yield 1;
  yield 2;
  yield 3;
}
const generator = test();
```

6. 生成器的其他 api

- return 方法：调用该方法，可以提前结束生成器函数，从而提前让整个迭代过程结束(传递的参数就是 value 值)

- throw 方法：调用该方法，可以在生成器即函数体内部相应位置产生一个错误

> 调用生成器函数并不会导致函数内部的代码执行，它只是简单的给你返回一个生成器对象
