# 迭代器

es6里面比较复杂的地方：异步处理promise和迭代器、生成器。模糊的地方多看几遍

本章节主要难在抽象。尽量多理解

## 背景知识（思想层面）

1. 什么是迭代？

从一个数据集合中按照一定的顺序，不断取出数据的过程（高度抽象的概念。不要去想代码）

2. 迭代和遍历 for-in 的区别？

迭代强调的是依次取出数据这个动作，并不保证取多少，也不保证把所有的数据取完

遍历强调的是要把整个数据依次全部取出(即完整性)

现实生活中，产品迭代就差不多是这个意思。产品经过几次迭代改进

3. 迭代器(封装取数据的过程，涉及到计算机语言层面的知识)

对迭代过程的封装，在不同的语言中有不同的表现形式，通常为对象

即迭代是一个一个的拿数据。很多场景都可能迭代，为了避免重复代码。对迭代的过程进行封装，封装的结果就是迭代器

和循环的区别：
- 循环时，默认操作的数据集合是已知的
- 迭代时，可以直接操作迭代器，让迭代器去操作

4. 迭代模式

一种设计模式，用于统一迭代过程，并规范了迭代器规格：（迭代器要有什么能力）

- 迭代器应该具有得到下一个数据的能力

- 迭代器应该具有判断是否还有后续数据的能力

## js 中的迭代器（代码层面）

js 规定，如果一个对象具有 next 方法，并且该方法返回一个对象，该对象的格式如下：

```js
//{value:值,done:是否迭代完成}
const obj = {
  next() {
    return {
      value: "?", //表示下一个属性的值
      done: "?", //布尔类型，表示是否迭代完成。若后续没有数据即下一个属性没有值就是迭代完成
    };
  }, //若一个对象满足：有next方法，next方法返回一个对象，对象里面有value和done属性。可以认为该对象是一个迭代器
};
```

则认为该对象是一个迭代器

含义：

- next 方法：调用该方法用于得到下一个数据的值

- 返回return的对象
  - value属性：表示下一个数据的值
  - done：boolean，是否迭代完成。即若后续没有数据就是迭代完成true，否则是false

目的：调用 next 得到下一个数据从而实现一个一个拿数据的过程

迭代器<=>仓库管理员

```js
const arr = [1, 2, 3, 4, 5];
for (let i = 0; i < arr.length; i++) {
  const element = arr[i];
} //循环一定要操作数据集合。若不是真数组就需要涉及到转换为真数组
//即循环相当于亲自到仓库取数据。迭代器则是让管理员帮你拿数据，本人不和仓库打交道；你不用管他是怎么拿的
const iterator = {
  i: 0, //表示当前的数组下标
  next() {
    return {
      value: arr[this.i++],
      done: this.i > arr.length,
    };
  },
}; //该迭代器用来迭代数组arr。每次调用next取到arr的下一项
//一旦这个迭代器写完之后，不用再关注操作的数组是什么样的，很灵活；抽象了整个取数据的过程。想调用几次调用几次
// console.log(iterator.next()); //,.....
//实现：让迭代器不断地取出下一个数据，直到没有数据为止
let data = iterator.next();
while (!data.done) {
  //只要没有迭代完成，则取出数据  
  console.log(data);
  //进行下一次迭代
  data = iterator.next();
}
console.log("迭代完成"); //整个迭代过程没有操作数组。即将要操作的数据集合和取数据的过程分开
//以上的这个迭代器不通用
```

```js
const arr1 = [1, 2, 3, 4, 5];
const arr2 = [6, 7, 8, 9, 0];
/**
 * 迭代器创建函数：根据你提供的数组arr创建通用的迭代器。帮你返回一个迭代器
 */
function createIterator(arr) {
  let i = 0;
  return {
    next() {
      return {
        value: arr[i++],
        done: i > arr.length,
      };
    },
  };
}
const iterator = createIterator(arr2);
let data = iterator.next();
while (!data.done) {
  console.log(data);
  data = iterator.next();
}
console.log("迭代完成");
```

```js
//实现：一次得到斐波那契数列前面n位的值   1 1 2 3 5 8 ....
//有的时候不能确定到底要使用多少位。这种场景适合迭代器
//创建一个斐波那契数列的迭代器。取一个无限长的数据用迭代器最好。
function createFeiboIterator() {
  let prev1 = 1,
    prev2 = 1, //前1位和前2位
    n = 1; //表示当前是斐波那契数列的第几位
  return {
    next() {
      let value;
      if (n <= 2) {
        value = 1;
      } else {
        value = prev1 + prev2;
      }
      const result = {
        value,
        done: false, //斐波那契数列是一个无限延伸下去的数列
      };
      prev2 = prev1;
      prev1 = result.value;
      n++;
      return result;
    },
  };
}
const iterator = createFeiboIterator();
```