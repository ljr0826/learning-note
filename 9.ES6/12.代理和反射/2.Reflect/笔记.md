# Reflect 反射（本章重点）

代理和反射往往是作为一个整体出现的。代理能做出来丰富的效果，但是反射最重要，一定要理解清楚

涉及到底层的一些api，所以本章节有兼容性问题

1. Reflect 是什么？

Reflect 是一个内置的对象(ES6 提出的)，它提供了一系列的方法，可以让开发者通过调用这些方法，访问一些 js 底层功能

由于它类似于其它语言的**反射**，因此取名为 Reflect

2. 它可以做什么？

使用 Reflect 可以实现诸如属性的赋值与取值、调用普通函数、用new调用构造函数、判断属性是否存在于对象中等等功能

3. 这些功能不是已经存在了吗？为什么还需要用 Reflect 实现一次？

有一个重要的理念，在 ES5 就被提出：减少魔法、让代码更纯粹（用api代替一些看着太神奇的语法）

这种理念很大程度上是受到函数式编程的影响(更加适应函数式编程)

ES6 进一步贯彻了这种理念，它认为，对属性内存的控制、原型链的修改、函数的调用等等，这些都属于底层实现，属于一种魔法；因此，需要将他们提取出来，形成一个正常的 API，并高度聚合到某个对象中，于是造就了 Reflect 对象。(Reflect 对象中有许多 API 都可以使用过去的某种语法或其他 API 实现)

4. 它里面提供了哪些 API 呢？

- Reflect.set(对象 target,属性名 propertyKey,属性值 value)：设置对象 target 的属性 propertyKey 的值为 value，等同于给对象的属性赋值

- Reflect.get(target,propertyKey,value)：读取对象 target 的属性 propertyKey，等同于读取对象的属性值

- Reflect.apply(target,thisArgument,argumentsList)：调用一个指定的函数，并绑定 this 和参数列表。等同于函数调用

- Reflect.deleteProperty(target,propertyKey)：删除一个对象的属性

- Reflect.defineProperty(target,propertyKey,attributes)：类似于 Object.defineProperty，不同的是如】如果配置出现问题，返回 false 而不是报错。可以认为Object.defineProperty内部实现就是这个方法

- Reflect.construct(target,argumentsList)：用构造函数的方法创建一个对象

- Reflect.has(target,propertyKey)：判断一个对象是否拥有一个属性(类似于 in 关键字)

- 其他 API：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect

```js
const obj = {
  a: 1,
  b: 2,
};
// obj.a = 10; //这种在函数式编程中就是一个魔法
Reflect.set(obj, "a", 10); //使用一个底层的实现给obj的属性a设置为10
// console.log(obj.a);
console.log(Reflect.get(obj, "a")); //使用一个底层的实现将obj的属性a读取出来
// delete obj.a;
Reflect.deleteProperty(obj, "a"); //删除obj中的属性a
// console.log("a" in obj);
console.log(Reflect.has(obj, "a")); //对象里面是否有属性a

function method(a, b) {
  console.log("method", a, b);
}
// method(3, 4); //认为函数调用也是一种底层实现。因为要找到函数的内存空间，建立上下文，往执行栈里加等
Reflect.apply(method, null, [3, 4]); //参数分别是函数、this指向、参数列表

function Test(a, b) {
  this.a = a;
  this.b = b;
}
// const t = new Test(1, 3);
const t = Reflect.construct(Test, [1, 3]); //参数是：构造函数、参数列表
```

本节课最主要是理解这些api为什么要出现。更好的适应函数式编程（目前使用的不多，但js拥有了函数式编程的能力）