# proxy应用-可验证的函数参数

比如说：一些函数的参数对数据类型有要求（比如想要两个数字相加

```js
function sum(a, b) {
  return a + b;
}
//若反射里面有这样的api，代理就可以重写这样的api
//得到一个可验证的函数：传递一个函数以及需要的数据类型进来
//返回一个新的函数。调用的时候就调用这个新的函数
function validatorFunction(func, ...types) {
  //以前的写法
  // return function (...argumentList) {
  //   types.forEach((t, i) => {
  //     if (typeof argumentList[i] !== t) {
  //       throw new TypeError(
  //         `第${i + 1}个参数${argumentList[i]}不满足类型`
  //       );
  //     }
  //   });
  //   return func(...argumentList);
  // };
  return new Proxy(func, {
    apply(target, thisArgument, argumentList) {
      types.forEach((t, i) => {
        if (typeof argumentList[i] !== t) {
          throw new TypeError(
            `第${i + 1}个参数${argumentList[i]}不满足类型`
          );
        }
      });
      return Reflect.apply(target, thisArgument, argumentList);
    },
  });
}
const sumProxy = validatorFunction(sum, "number", "number"); //函数变得通用并且没有浪费内存空间
console.log(sumProxy("2", 6));
```