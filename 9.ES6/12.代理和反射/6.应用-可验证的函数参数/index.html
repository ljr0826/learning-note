<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
  </head>

  <body>
    <script>
      function sum(a, b) {
        return a + b;
      }
      //若反射里面有这样的api，代理就可以重写这样的api
      //得到一个可验证的函数：传递一个函数以及需要的数据类型进来
      //返回一个新的函数。调用的时候就调用这个新的函数
      function validatorFunction(func, ...types) {
        //以前的写法
        // return function (...argumentList) {
        //   types.forEach((t, i) => {
        //     if (typeof argumentList[i] !== t) {
        //       throw new TypeError(
        //         `第${i + 1}个参数${argumentList[i]}不满足类型`
        //       );
        //     }
        //   });
        //   return func(...argumentList);
        // };
        return new Proxy(func, {
          apply(target, thisArgument, argumentList) {
            types.forEach((t, i) => {
              if (typeof argumentList[i] !== t) {
                throw new TypeError(
                  `第${i + 1}个参数${argumentList[i]}不满足类型`
                );
              }
            });
            return Reflect.apply(target, thisArgument, argumentList);
          },
        });
      }
      const sumProxy = validatorFunction(sum, "number", "number"); //函数变得通用并且没有浪费内存空间
      console.log(sumProxy("2", 6));
    </script>
  </body>
</html>
