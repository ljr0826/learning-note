# proxy应用-偷懒的构造函数

大家写es6里面的class类的时候，有一个地方特别恶心

```js
class User {
  // constructor(firstName, lastName, age) {
  //   this.firstName = firstName;
  //   this.lastName = lastName;
  //   this.age = age; //这一部分赋值，写起来特别恶心
  //   //可以用Reflect.constructor代理重写
  // }
}
//因此可以将类写一个代理出来。实现：没有constructor中this赋值的一系列操作
function ConstructorProxy(Class, ...propNames) {
  return new Proxy(Class, {
    construct(target, argumentList) {
      // console.log("参数列表", argumentList);
      const obj = Reflect.construct(target, argumentList); //相当于是调用了构造器User
      propNames.forEach((name, i) => {
        obj[name] = argumentList[i];
      });
      return obj;
    },
  });
}
const UserProxy = ConstructorProxy(User, "firstName", "lastName", "age");
const obj = new UserProxy("顾", "昀", 27);
console.log(obj);
class Monster {}
const MonsterProxy = ConstructorProxy(
  Monster,
  "attack",
  "defence",
  "hp",
  "rate",
  "name"
); //通用函数
const m = new MonsterProxy(10, 20, 100, 30, "小怪兽");
console.log(m);
```