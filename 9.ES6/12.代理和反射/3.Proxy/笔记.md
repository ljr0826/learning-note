# Proxy 代理

代理的功能：提供了修改底层实现的方式（所以要做成一个api的原因

```js
//代理一个目标对象
//target：目标对象
//handler:是一个普通对象，其中可以重写底层实现
//返回一个代理对象
new Proxy(target, handler);
```

<img src="1.jpg">
就是谈事情和我的律师/代理谈
律师怎么和我谈，外面的人别管

es6推出反射的一个原因就是为了实现代理

```js
const obj = {
  a: 1,
  b: 2,
};
const proxy = new Proxy(obj, {
  set(target, propertyKey, value) {
    // console.log(target, propertyKey, value);
    // target[propertyKey] = value;//重写代理
    //...一些额外的事情
    Reflect.set(target, propertyKey, value); //这种方式更加容易阅读。即重写代理的属性的原理还是反射提供的api
  }, //我们不能重写目标里面的底层实现，但是能够实现重写代理里面的底层实现
  get(target, propertyKey) {
    if (Reflect.has(target, propertyKey)) {
      return Reflect.has(target, propertyKey);
    } else {
      return -1;
    }
  },
  has(target, propertyKey) {
    return false;
  },
}); //反射里面的方法在配置里面都可以重写
proxy.a = 1; //以后通过代理和目标对象打交道
console.log(proxy.a);
console.log(proxy.d); //没有这个属性，得到-1》即代理里面怎么写的就怎样运行
console.log("a" in proxy); //false
```