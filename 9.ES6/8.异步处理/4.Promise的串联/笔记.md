# Promise 的串联

作业队列的多个处理程序适用于事件的多种处理程序。但不适用于Promise的串联

当后续的 Promise 需要用到之前的 Promise 的处理结果时，需要 Promise 的串联（怎么处理呢？）

Promise 对象中无论是 then 方法还是 catch 方法，他们都具有返回值，返回的是一个全新的 Promise 对象，它的状态满足下面规则：
1. 如果当前的 Promise 是未决阶段，得到的新的 Promise 是挂起状态
2. 如果当前的 Promise 是已决阶段，
   1. 会运行相应的后续处理函数，并将后续处理函数的返回值(结果)作为 resolve 状态数据，应用到新的 Promise 中；
   2. 如果后续处理函数发生错误，则会把返回值作为 rejected 状态数据，应用到新的 Promise 中。

**后续的 Promise 一定会等到前面的 Promise 有了后续处理结果后，才会变成已决状态**

```js
const pro1 = new Promise((resolve, reject) => {
  throw 1;
});
const pro2 = pro1.then(
  (res) => res * 2,
  (err) => err * 3
); //这个then属性的回调是异步函数，会放到事件队列中等待执行
console.log(typeof pro2); //pro2是一个对象
console.log(pro1); //pro1的状态是已决状态
console.log(pro2); //pro2的状态是pending，因为then属性是异步处理的
pro2.then(
  (res) => console.log(res * 2),
  (err) => console.log(err * 3)
); //1*3*2=6
```

then 返回的 Promise 对象一开始一定是挂起状态(因为 thenable 后续处理函数是异步的)

```js
const pro1 = new Promise((resolve, reject) => {
  throw 1;
});
const pro2 = pro1.then(
  (res) => res * 2,
  (err) => err * 3
); //这个pro2是第一个then函数调用得到的。和下面的catch函数属于不同的作业队列
pro1.catch((err) => {
  err * 2;
}); //和上面的then函数无关，不存在覆盖之类的情况
pro2.then(
  (res) => console.log(res * 2),
  (err) => console.log(err * 3)
); //1*3*2=6
//前面then或catch回调函数的结果是后面promise对象已决状态的数据
```

如果前面的 Promise 的后续处理，返回的是一个 Promise，则返回的新的 Promise 的状态和后续处理返回的 Promise 状态保持一致。

```js
const pro1 = new Promise((resolve, reject) => {
  resolve(1);
});
const pro2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve(2);
  }, 3000);
});
const pro3 = pro1.then((result) => {
  console.log("结果出来了，得到的是一个promise"); //这个代码在pro1变成已决阶段后就会运行
  return pro2; //由于返回promise对象，导致pro3变成已决阶段的时间和pro2的保持一致
});
console.log(pro3); //pending状态
pro3.then((result) => {
  console.log(result); //3秒之后输出2
  //这里没写return相当于返回undefined
});

pro1
  .then((result) => {
    console.log("结果出来了，得到的是一个promise"); //这个代码在pro1变成已决阶段后就会运行
    return pro2; //由于返回promise对象，导致pro3变成已决阶段的时间和pro2的保持一致
  })
  .then((result) => {
    console.log(result); //3秒之后输出2
    //这里没写return相当于返回undefined
  })
  .then((result) => {
    console.log(result);
  });
  //见test1.html和test3.html
```
