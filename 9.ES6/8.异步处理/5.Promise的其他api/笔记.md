# Promise 的其他 api

不常见，但有时候可能会用到

## 原型成员(实例成员)

- then：注册一个后续处理函数，当 Promise 为 resolved 状态时运行该函数
  - 习惯上注册一个resolve状态的回调，但可以注册两个回调，一个resolve状态一个reject状态


- catch：注册一个后续处理函数，当 Promise 为 rejected 状态时运行该函数
  - 这两个then方法和catch方法之前已经详细学习过了


- finally：[ES2018]注册的一个后续处理函数(无参)，当 Promise 为已决状态时运行该函数（无论是resolve还是reject

> 同一个promise的catch和then方法不可能都执行。因为同一个promise的状态只能是resolve或reject

```js
const pro = new Promise((resolve, reject) => {
  resolve(1);
});
pro.finally((resp) => {
  console.log("finally1", resp); //没有参数，因为无论是then还是catch，只要到达已决状态就会运行
});
pro.finally(() => {
  console.log("finally2");
});
```

## 构造函数成员(静态成员)

- resolve(数据)：该方法返回一个 resolved 状态的 Promise，传递的数据作为状态数据
  - resolve方法的特殊情况：如果传递的数据是 Promise，则直接返回传递的 Promise 对象
  - 浏览器不一致，所以传递promise对象这种情况不会出现在面试题中

```js
const p = new Promise((resolve, reject) => {
  resolve(3);
});
const pro = Promise.resolve(p);
console.log(pro === p); //true。reject方法没有这种特殊情况
```

- reject(数据)：该方法返回一个 rejected 状态的 Promise，传递的数据作为状态数据

```js
const pro1 = new Promise((resolve, reject) => {
  // resolve(1); //这种场景：没有别的事情可以做，直接变成resolve的状态.等效于pro2
  reject(2); //这种场景：没有别的事情做，直接变成reject状态。等效于pro3
});
//等效于：
// const pro2 = Promise.resolve(1);
const pro3 = Promise.reject(2);
```

- all(iterable)：该方法返回一个新的 promise 对象，该 promise 对象在 iterable 参数对象里所有的 promise 对象都成功的时候才会触发成功；  
  - 暂时可以将iterable看作是promise对象形成的数组。实际上能够遍历的都可以
  -  一旦有任何一个 iterable 里面的 promise 对象失败则立即触发该 promise 对象的失败。这个新的 promise 对象在触发成功状态后，会把一个包含 iterable 里所有 promise 返回值的数组作为成功回调的返回值，顺序跟 iterable 的顺序保持一致；
  -  如果这个新的 promise 对象触发了失败状态，它会把 iterable 里第一个触发失败的 promise 对象的错误信息作为它的失败错误信息。Promise.all 方法常被用于处理多个 promise 对象的状态集合。也经常用来判断多个ajax请求的发送状态判断

```js
const proms = [];
function getRandom(min, max) {
  return Math.floor(Math.random() * (max - min) + min);
}
for (let i = 0; i < 10; i++) {
  proms.push(
    new Promise((resolve, reject) => {
      setTimeout(() => {
        if (i % 3 === 0) {
          reject(i);
          console.log(i, "失败");
        } else {
          resolve(i);
          console.log(i, "完成");
        }
      }, getRandom(1000, 5000));
    })
  );
}
console.log(proms);
//要求实现：等到所有的promise变成resolve状态后输出：全部完成
//使用Promise.all()方法，将数组传递进去会返回一个新的promise对象，
//这个返回的promise对象会在数组中所有的成员达到resolve状态后resolve
const pro = Promise.all(proms);
pro.then(
  (data) => {
    console.log("全部完成", data); //返回的promise对象中的数据，是数组中相应顺序的promise的resolve值
  },
  (err) => {
    console.log("失败信息", err); //若数组中有reject信息。会将第一个reject的信息作为返回的promis对象的信息
  }
);
```

- race(iterable)：当 iterable 参数里的任意一个子 promise 被成功或失败后，父 promise 马上也会用子 promise 的成功返回值或失败详情作为参数调用父 promise 绑定的相应句柄，并返回该 promise 对象(看谁先完成)
  - 即看谁跑得过谁，数组中的第一个成员如果是resolve，返回的promise对象就是resolve状态。reject同理

```js
const pro = Promise.race(proms);
pro.then((data) => {
  console.log("最快的是resolve", data);
});
pro.catch((err) => {
  console.log("最快的是reject", err);
});
```

后续有es7对promise的简化

```js
/*
      邓哥心中有二十个女神，他决定用更加高效的办法
      他同时给二十个女神表白，如果有女神同意，就拒绝其他的女神(先不做这个功能，用到另一个api。race方法不行)
      并且，当所有的女神回复完成后，他要把所有的回复都记录到日志进行分析（使用Promise.all方法）
      用代码模拟上面的场景
  */
function biaobai(god) {
  return new Promise((resolve, reject) => {
    // console.log(`邓哥向女神【${god}】发出了表白短信`);
    setTimeout(() => {
      if (Math.random() < 0.4) {
        console.log(god, "同意");
        resolve(true);
      } else {
        console.log(god, "拒绝");
        resolve(false);
      }
    }, Math.floor(Math.random() * (3000 - 1000) + 1000));
  });  
}
const proms = []; //记录表白数组
let hasAgree = null; //表示是否有女神同意
for (var i = 1; i <= 20; i++) {
  const pro = biaobai(`女神${i}`).then((data) => {
    if (data) {
      if (hasAgree) {
        console.log("不好意思，朋友用我手机恶作剧");
      } else {
        hasAgree = true;
        console.log("牵手成功");
      }
    }
    return data;
  });
  proms.push(pro);
}
Promise.all(proms).then((data) => {
  console.log("日志记录：", data);
});
```