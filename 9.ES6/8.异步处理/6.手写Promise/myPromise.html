<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      const MyPromise = (() => {
        const PENDING = "pending",
          RESOLVED = "resolved",
          REJECTED = "rejected",
          PromiseStatus = Symbol("PromiseStatus"), //当前状态
          PromiseValue = Symbol("PromiseValue"), //状态数据
          changeStatus = Symbol("changeStatus"), //改变状态
          thenables = Symbol("thenables"), //thenables作业队列
          catchables = Symbol("catchables"), //catchables作业队列
          settleHandle = Symbol("settleHandle"), //已决阶段的后续处理的通用函数
          linkPromise = Symbol("linkPromise"); //创建串联的promise

        return class MyPromise {
          //改变Promise的当前状态。queue执行的作业队列函数
          [changeStatus](newStatus, newValue, queue) {
            if (this[PromiseStatus] !== PENDING) {
              //状态无法变更
              return;
            }
            this[PromiseStatus] = newStatus;
            this[PromiseValue] = newValue;
            //执行相应作业队列中的函数
            queue.forEach((handler) => handler(this[PromiseValue]));
          }

          //处理已决阶段的后续处理函数。handler后续处理函数。immediatelyStatus需要立即执行的状态。queue作业队列
          [settleHandle](handler, immediatelyStatus, queue) {
            if (typeof handler !== "function") {
              return;
            }
            if (this[PromiseStatus] === immediatelyStatus) {
              setTimeout(() => {
                handler(this[PromiseValue]);
              }, 0);
            } else {
              queue.push(handler);
            }
          }

          //executor：表示未决状态下的处理函数
          constructor(executor) {
            this[PromiseStatus] = PENDING;
            this[PromiseValue] = undefined;
            this[thenables] = [];
            this[catchables] = [];
            const resolve = (data) => {
              this[changeStatus](RESOLVED, data, this[thenables]);
            };
            const reject = (reason) => {
              this[changeStatus](REJECTED, reason, this[catchables]);
            };
            try {
              executor(resolve, reject);
            } catch (err) {
              this[changeStatus](REJECTED, err);
            }
          }

          [linkPromise](thenable, catchable) {
            function exec(data, handler, resolve, reject) {
              try {
                const result = handler(data); //得到当前Promise的处理结果
                if (result instanceof MyPromise) {
                  result.then(
                    (d) => {
                      resolve(d);
                    },
                    (err) => {
                      reject(err);
                    }
                  );
                } else {
                  resolve(result);
                }
              } catch (err) {
                reject(err);
              }
            }

            return new MyPromise((resolve, reject) => {
              this[settleHandle](
                (data) => {
                  if (typeof thenable !== "function") {
                    //父级promise没有注册thenable
                    resolve(data);
                    return;
                  }
                  exec(data, thenable, resolve, reject);
                },
                RESOLVED,
                this[thenables]
              );

              this[settleHandle](
                (reason) => {
                  if (typeof catchable !== "function") {
                    //父级promise没有注册catchable
                    reject(reason);
                    return;
                  }
                  exec(reason, catchable, resolve, reject);
                },
                REJECTED,
                this[catchables]
              );
            });
          }

          then(thenable, catchable) {
            return this[linkPromise](thenable, catchable);
          }

          catch(catchable) {
            return this[linkPromise](undefined, catchable);
          }

          static all(proms) {
            return new MyPromise((resolve, reject) => {
              const results = proms.map((p) => {
                const obj = {
                  result: undefined,
                  isResolved: false,
                };
                p.then(
                  (data) => {
                    obj.result = data;
                    obj.isResolved = true;
                    //判断是否所有的全部完成
                    const unResolved = results.filter((r) => !r.isResolved);
                    if (unResolved.length === 0) {
                      //全部完成
                      resolve(results.map((r) => r.result));
                    }
                  },
                  (reason) => {
                    reject(reason);
                  }
                );
                return obj;
              });
            });
          }

          static race(proms) {
            return new MyPromise((resolve, reject) => {
              proms.forEach((p) => {
                p.then(
                  (data) => {
                    resolve(data);
                  },
                  (err) => {
                    reject(err);
                  }
                );
              });
            });
          }

          static resolve(data) {
            if (data instanceof MyPromise) {
              return data;
            }
            return new MyPromise((resolve) => {
              resolve(data);
            });
          }

          static reject(reason) {
            return new MyPromise((reject) => {
              reject(data);
            });
          }
        };
      })();

      const pro = MyPromise.resolve(1);
      pro.then((result) => {
        console.log(result);
      });
      console.log(pro);
    </script>
  </body>
</html>
