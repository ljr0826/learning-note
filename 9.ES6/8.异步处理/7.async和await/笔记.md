# async 和 await(语法糖)

async 和 awite 是 ES2016(ES7) 新增的两个关键字，他们借鉴了 ES2015 中生成器在实际开发中的应用，目的是简化 Promise api 的使用，并非是替代 Promise。

## async关键字（这个单词是异步的意思）

目的是简化在函数的返回值中对 Promise 的创建(因为我们通常使用一个函数return一个promise)

async 用于修饰函数的(无论是函数字面量还是函数表达式)，将这个关键字放置在函数最开始的位置，被修饰函数的返回结果一定是 Promise 对象

```js
async function test() {//这个是语法糖。被async关键字修饰的函数，返回的结果一定是promise对象
  console.log(1);
  // throw 3;//想要实现reject状态就抛出错误
  return 2; //表示这个Promise完成时的状态数据即resolve是2
  //注意：即使没有return。使用async关键字修饰的函数的返回值依旧是promise对象
}
//等效于
function test() {
  return new Promise((resolve, reject) => {
    console.log(1);
    resolve(2);
  });
}
```

> 只要被async关键字标记的函数，返回的结果一定是promise对象（即使函数中没有return）

```js
//如果使用async关键字修饰的函数return的是promise对象。则相当于没有使用async关键字修饰函数
async function test(){
  return new Promise((resolve,reject)=>{
    resolve(4)
  })//即相当于没有用async关键字修饰函数。但是这样其实没有必要
}
```

```js
async function biaobai(god) {
  setTimeout(() => {
    if (Math.random() < 0.4) {
      console.log(god, "同意");
      // resolve(true);
      return true; //注意：在这里返回相当于是setTimeout的回调函数的返回。而不是async修饰的函数的返回
      //因此，这种情况不适用async。只能老老实实的使用new Promise
    } else {
      console.log(god, "拒绝");
      resolve(false);
    }
  }, Math.floor(Math.random() * (3000 - 1000) + 1000));
}
```

## await关键字（这个单词是等待的意思）

**await 关键字必须出现在 async 函数中！！！**

await 用在某个表达式之前，如果表达式是一个 Promise，则得到的是 thenable 中的状态数据

这两个关键字也并不是消除回调函数，而是一个语法糖。内部原理还是回调。只是看着舒服

```js
async function test1() {
  console.log(1);
  return 2;
}
async function test2() {
  const result = await test1();
  //这句话的意思是：等test1成功到达已决状态后，将test1的状态数据赋值给result
  console.log(result);
  // return new Promise((resolve, reject) => {
  //   test1().then((data) => {
  //     const result = data;
  //     console.log(result);
  //      resolve();
  //   }); //即相当于这样写
  // });
}
test2();

//见ajax.html实例
```

```js
(async () => {
  const gods = ["女神1", "女神2", "女神3"];
  for (let i = 0; i < gods.length; i++) {
    const god = gods[i];
    //循环中对promise对象的特殊处理：若当前循环等待的promise没有resolve，下一次循环不运行
    const result = await biaobai(god);
    if (result) {
      console.log(`${god}同意了。不用再表白了！！！`);
      break;
    } else {
      console.log(`${god}拒绝了`);
    }
  }
})();
//因为async既可以修饰函数字面量。也可以修饰函数表达式
//由于await必须放在async函数中。所以避免内存开销。可以将async修饰立即执行函数
```

如果 await关键字修饰的不是表达式 Promise，则会将其使用 Promise.resolve 包装后按照规则运行。
```js
async function test() {
  const result = await 1;
  console.log(result);
}
//相当于：
async function test() {
  return new Promise((resolve, reject) => {
    Promise.resolve(1).then((data) => {
      const result = data;
      console.log(result);
      resolve();
    });
  });
}
test();
console.log(123);
```

rejected 状态的处理情况：try catch 的应用
```js
async function getPromise() {
  if (Math.random() < 0.5) {
    return 1;
  } else {
    throw 2;
  }
}
async function test() {
  try {
    const result = await getPromise();
    console.log("正常状态", result);
  } catch (err) {
    console.log("错误状态", err);
  }
}
test();
//相当于：
getPromise().then(
  (data) => {
    console.log("正常状态", data);
  },
  (err) => {
    console.log("错误状态", err);
  }
);
```

```js
function delay(duration) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve();
    }, duration);
  });
}
async function biaobai(god) {
  console.log(`邓哥向${god}发出了表白短信`);
  await delay(Math.floor(Math.random() * (1000 - 500) + 500));
  return Math.random() < 0.2;
}
```

es6专门推出fetch api来适配promise以更好的完成ajax请求