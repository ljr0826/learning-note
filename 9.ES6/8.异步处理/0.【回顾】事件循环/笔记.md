# 【回顾】事件循环

> es6针对异步处理推出了新的api----Promise(异步处理涉及到一块基础知识--事件循环)

```js
console.log("a");
setTimeout(() => {
  console.log("b");
}, 0);
console.log("c");
//输出的顺序是：a c b
```

js 运行的环境称之为宿主环境(es语言不仅可以运行在浏览器，还可以运行在服务器，客户端，手机端等。语言本身可以运行在各种环境中)
  - 浏览器端Javascript = web api + es语言
  - 服务器端 NodeJs = node js + es语言

执行栈：call stack，一个数据结构（像是数组就可以做成一个栈），数据添加一定是添加在栈顶。用于存放各种函数的执行环境，每一个函数执行之前， 它的相关信息(也叫执行上下文)会加入到执行栈（入栈push）。函数调用之前，创建执行环境，然后加入到执行栈；函数调用之后，销毁执行环境（出栈pop）

<img src="stack.jpg"/>

**js 引擎永远执行的是执行栈的最顶部**。(整个js执行只有一个执行栈)

```js
function a() {
  console.log("a");
  b();
}
function b() {
  console.log("b");
  c();
}
function c() {
  console.log("c");
}
console.log("global");
a();
//所有js代码执行之前，都必须有全局执行上下文。因为所有代码的起始位置都是全局环境
//global a b c

      //求斐波那契数列第n位的值（递归：函数式编程里面的思想，属于声明式语言。不要去研究它内部的运作）
      function getFeibo(n) {
        if (n === 1 || n === 2) {
          return 1;
        }
        return getFeibo(n - 1) + getFeibo(n - 2);
      }
      console.log(getFeibo(4));
```

异步函数：某些函数不会立即执行，需要等到某个时机到达后才会执行，这样的函数称之为异步函数。比如事件处理函数。异步函数的执行时机，会被宿主环境控制(异步是js最显著的特点，因为js的主线程是一个单线程的应用程序)

浏览器宿主环境中包含 5 个线程：（尽管如此，js代码的执行线程只有一个。js是一个单线程的语言，因此异步）
1. js 引擎：负责执行执行栈的最顶部代码(js 引擎只占用一个线程)
2. GUI 线程：负责渲染页面(js 线程和 GUI 线程会相互等待)
3. 事件监听线程：负责监听各种事件
4. 计时线程：负责计时
5. 网络线程：负责网络通信（比如ajax

当上面的线程发生了某些事情，如果该线程发现，这件事情有处理程序。他会将该处理程序加入到一个叫做事件队列的内存中。当 js 引擎发现，执行栈中已经没有了任何内容后，会将事件队列中的第一个函数加入到执行栈中执行

js 引擎对事件队列的取出执行方式，以及与宿主环境 web api 的配合，称之为事件循环event loop。

<img src="event loop.png" />

> 个人总结：(事件循环：js 引擎运行时遇到异步函数会通知宿主环境中的相应线程，待时机到达后，将处理程序加入到事件队列的内存中，当执行栈中没有任何内存时，会将事件队列中的第一个函数加入到执行栈中执行

> 以后遇到异步函数就要想到事件循环

事件队列在不同的宿主环境中有所差异，大部分宿主环境会将事件队列进行细分。在浏览器中。事件队列分为两种：
- 宏任务(队列)：macroTask，计时器结束的回调、事件回调、http 回调等等绝大部分异步函数进入宏队列
- 微任务(队列)：MutationObserver，Promise 产生的回调进入微队列（相当于vip通道

当执行栈清空时。js 引擎首先会将微任务中的所有任务依次执行结束，如果没有微任务，则执行宏任务

> MutationObserver api 用于监听某个 DOM 对象的变化

```html
<ul id="container"></ul>
<button id="btn">点击</button>
<script>
  let count = 1;
  const ul = document.getElementById("container");
  document.getElementById("btn").onclick = function () {
    var li = document.createElement("li");
    li.innerText = count++;
    ul.appendChild(li);
    console.log("添加了一个li");
  };
  //监听ul
  const observer = new MutationObserver(() => {
    //当监听的dom元素发生变化时运行的回调函数
    console.log("ul元素发生了变化");
  }); //这个异步函数在微队列
  observer.observe(ul, {
    attributes: true, //监听属性的变化
    childList: true, //监听子元素的变化
    subtree: true, //监听子树的变化
  }); //参数表示：监听的元素、监听的相关配置
  // observer.disconnect(); //取消监听
</script>
```