# 类的继承

在面向对象里面，有一种类之间的关系叫继承。即类就是一个类型，js里本身提供了一些类型比如字符串、布尔、对象等。

类型与类型之间有一些关系，有一种关系就叫做继承。

如何判断两个类有继承关系？

如果两个类 A 和 B，如果可以描述为：B 是 A(B 拥有 A 里的所有特征)，则 A 和 B 形成继承关系。

如果 B 是 A，则可以说：
1. B 继承自 A
2. A 派生 B
3. B 是 A 的子类
4. A 是 B 的父类

如果 A 是 B 的父类，则 B 会自动拥有 A 中的所有实例成员。这种关系在面向对象中特别有用

新的关键字：
- extends：继承，用于类的定义
- super
  - 直接当作函数调用，表示父类构造函数
  - 如果当作对象使用，则表示父类的原型

注意：ES6 要求，如果定义了 constructor，并且该类是子类，则必须在 constructor 的第一行手动调用父类的构造函数。因为这样才能构成继承关系。如果子类不写 constructor，则会有默认的构造器

在面向对象里面，继承关系一定是单根的，一个子类只能继承自一个父类

```js
//原来的方法
function Animal(type, name, age, sex) {
  this.type = type;
  this.name = name;
  this.age = age;
  this.sex = sex;
}
Animal.prototype.print = function () {
  console.log(`【种类】：${this.type}`);
  console.log(`【名字】：${this.name}`);
  console.log(`【年龄】：${this.age}`);
  console.log(`【性别】：${this.sex}`);
};
function Dog(name, age, sex) {
  Animal.call(this, "犬类", name, age, sex); //借用父类的构造函数，绑定this
  //想要把原型上的方法也继承过来。
}
Object.setPrototypeOf(Dog.prototype, Animal.prototype); //实现Dog继承自Animal的原型
const dog = new Dog("旺财", 3, "公");
console.log(dog);
```

```js
//类写法的改进
class Animal {
  constructor(type, name, age, sex) {
    this.type = type;
    this.name = name;
    this.age = age;
    this.sex = sex;
  }
  print() {
    console.log(`【种类】：${this.type}`);
    console.log(`【名字】：${this.name}`);
    console.log(`【年龄】：${this.age}`);
    console.log(`【性别】：${this.sex}`);
  }
}
class Dog extends Animal {
  //关键字extends，表示继承，用于类的定义
  constructor(name, age, sex) {
    if(new.target === Animal){
      throw new TypeError("你不能直接创建Animal对象，应该通过子类创建")
    }
    //若子类定义了constructor，则必须在constructor第一行调用super，否则会报错
    super("犬类", name, age, sex); //关键字super，直接当作函数调用，表示调用父类的构造函数
    this.loves = "吃骨头"; //子类特有的属性
  }
  print() {
    //调用父类的print
    super.print(); //super当作对象使用的话，表示父类的原型即Animal.prototype
    console.log(`【爱好】：${this.loves}`); //自己特有的代码
  } //和父类冲突，采用自己的方法
  shout() {
    console.log("汪汪");
  } //子类特有的原型方法
  //类里面会自动帮你搞定原型链间的继承关系
}
const dog = new Dog("旺财", 3, "公");
dog.print();
console.log(dog);
```

【冷知识】
- 用 js 制作抽象类：一般是父类，不能通过该类创建对象（比如，动物是一个高度抽象的概念，是一个统称；我们可以创建一个狗、一个猫，但是动物是抽象的）所以希望不用创建父类的对象，认为他的逻辑是有问题的
- 正常情况下， this 的指向，this 始终指向具体的类的对象，即当前对象（与super无关）
