# 类的其他书写方式(类的其他语法)

兼容性问题以后又babel来解决

## 可计算的成员名

和可计算的属性名类似。见下单元示例js

## getter 和 setter（设置属性的相关信息）

以前使用 Object.defineProperty 可定义某个对象成员属性的读取和设置(也可以将数据属性转化为存取器属性)

类里面使用 getter 和 setter 控制的属性的相关信息，注意控制的属性不在原型上（在实例对象上）

格式上注意 get 无形参，set 单参

```js
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
  //创建一个age属性，并给他加上setter，给改属性赋值时，会运行该函数（叫赋值器
  set age(val) {
    if (val < 0) {
      val = 0;
    } else if (val > 100) {
      val = 100;
    }
    this._age = val;
  }
  //创建一个age属性，并给他加上getter，读取该属性时，会运行该函数（叫读取器
  //读取器和赋值器，统称为访问器
  get age() {
    return this._age + "岁";
  }
}
var a = new Person("神医", 3);
```

## 静态成员

构造函数本身的成员（即有时希望给函数本身加上一些成员

<img src="img.jpg" />
- 原型上的成员叫实例成员，也叫原型成员
- 静态成员不能通过对象来访问

**使用 static 关键字定义的成员即为静态成员**

```js
//比如做一个中国象棋的游戏
class Chess {
  constructor(name) {
    this.name = name;
    // this.width = 50; //每个棋子的宽高都是一样的
    // this.height = 50; //如果这样写代码，我需要先创建一个棋子对象才能获取到他的宽高
    //但是实际上，这样不只是浪费内存空间那么简单；
    //即不是有了棋子才有宽高。没有棋子宽高也应该是定下来的，所以使用静态属性合适
  }
  static width = 50;
  static height = 50; //静态属性
  static method() {} //静态方法
}
// Chess.width = 50;
// Chess.height = 50; //静态属性以前使用这种写法，但是他又和类分开的，这样不好；es6规定也应该写在类里面
const ch1 = new Chess("马");
console.log(Chess.width, Chess.height);
Chess.method();
```

## 字段初始化器(ES7)是实例成员

即写了一个成员。直接给他赋值。比如```static a = 1;```。也就是es6提供了静态方法、es7提供了静态属性的语法

某些属性本身具有默认值，也不需要在构造函数里对它进行初始化；这些属性可以使用 ES7 字段初始化器的语法来书写

```js
//有时候有些属性本身就具有默认值。也不需要在构造函数里面对他进行初始化
class Test {
  constructor() {
    // this.c = 3; //这种不来自于任何参数，直接赋值的字段就可以使用es7的字段初始化器
    this.d = this.b + this.c;
  }
  static a = 1; //这个是静态成员
  b = 2;
  c = 3; //即可以直接这么写。字段初始化器写的是实例成员
}
const t = new Test();
console.log(t);
```

**注意**：
- 使用 static 的字段初始化器，添加的是静态成员
- 没有使用 static 的字段初始化器，添加的成员位于对象上即是实例成员
- 箭头函数在字段初始化器位置上指向当前对象

```js
//有时候有些属性本身就具有默认值。也不需要在构造函数里面对他进行初始化
class Test {
  constructor() {
    this.a = 123;
  }
  hit(){};//这个是原型方法，下面那个更改后是实例方法
  print = () => {
    console.log(this.a); //有时为了绑定this让他始终指向当前这个对象，使用箭头函数
  }; //注意这个print方法此时是字段初始化器。不再是原型方法，而是每个对象上都有这个方法
  //会占用对象的空间。不在乎空间浪费时可以使用他（字段初始化器相当于在constructor中写了this.print方法
}
const t = new Test();
t.print();
const p = t.print;
p(); //this指向容易混乱。使用字段初始化器可以解决这个问题
```

## 类表达式

```js
//类也是js里面的一等公民（类class在js里面本质上就是函数）
const A = class {
  //匿名类：表达式不需要名字，这样写就是一个类表达式
  a = 1;
  b = 2;
};
const a = new A();
console.log(a);
```

## 【扩展】装饰器 Decorator(ES7)

目前还没有成为正式的标准，了解一下。将来可能还有大的改动

这个功能可以解决横切关注点问题。现在了解一下。后续学习ts和babel时会解决这个问题

```js
class Test {
  constructor() {} //暂时没有实例成员，可以不写constructor
  @Obsolete //目前会报错，不支持当前语法，以后学习了ts或babel可以有办法让他支持，但是现在做不到
  print() {
    console.log("print方法");
  } //若是这个方法过期了，但是为了避免往期项目受到影响所以不会删除这个方法，而是给到一个提示
  //即方法若过时了就标记一下，若是可以用了再去掉标记。若是更改函数体内容来标记就太low了，而且麻烦容易出问题
  //这是一个典型的横切关注点的问题，就是有些功能具有通用性，和类里面具体的功能无关，是单独抽离出来的功能
  //这种问题最合适的就是使用装饰器：即标记已过期，做标记用。语法是```@装饰器名称```
  //装饰器的本质是一个函数，有三个参数：类本身，方法名字，方法的相关信息(类似于属性描述符)
}
function Obsolete(target, methodName, descriptor) {
  console.log(target, methodName, descriptor);//function Test     print     {value:func...}
  const oldFunc = descriptor.value;
  descriptor.value = function(...args){
    console.warn(`${methodName}方法已过时`)
    oldFunc.apply(this,args)
  }
}
```

