# 数组

数组经常和判断循环一起用，但不属于流程控制

数组用于存放多个数据。（可以不用创建多个变量了）

## 创建一个数组(创建数据的方法)

日后创建数组有很多方法

1. new Array(长度)

长度：数据里面的数据总数，长度一定是一个非负整数、

```js
var arr = new Array(20); //创建了一个长度为20的数组。new关键字日后会专门学习
```

变种写法：new Array(数据,数据,数据,....)

创建一个数组，同时初始化每一项的值

数组项：数组其中一项的数据
```js
var arr = new Array(1, 5, 23, 46); //创建了一个长度（自动计算）为4，数据分别是1、5、23、46
```

2. [数据(数组的数据),数据,数据...]

创建一个数组，并初始化其每一项的值

```js
var arr = [1, 5, 23, 46];
```

> 数组里面存放的数据不一定是number类型。任何数据都可以

## 认识数组的本质

数组的本质是一个对象。只是写法上有一些差异，会默认生成一些属性

对象的成员叫做属性。数组也是对象，所以也有属性

- length 属性：表示数组的长度，length会自动变化，值为最大下标+1

```js
arr.abc = "1234t5dscx";
arr[50] = 333; //发现length属性会自动变化。忽略非数字类型字符串的属性名。值为最大下标+1
```

- 数字字符串属性：在数组里面叫做下标，也叫索引，相当于数组中每个数据的编号，注意下标从 0 开始排列

```js
//面试题：
var arr = [3, 6, 23, 4];
arr[0] = 10; //属性始终是字符串，不可能是其他数据类型
arr["0"] = 5;
console.log(arr[0], arr["0"]); //5  5
```

可以给length属性赋值：连续下标的取值范围：0 ~ length - 1，但是如果给 length 直接赋值，会导致数组可能被截断，非数字属性会保留

！实际开发中，不要给 length 赋值。让length保持自动变化。不要画蛇添足，否则会产生很多怪异的现象

所以，心里要认为length属性是只读的

## 下标

通常情况下，数组的下标是连续的。但是有可能将来不连续了（很多种情况会造成这种情况）

下标不连续的数组，叫做稀松数组。稀松数组在某些数组遍历的时候得不到东西

```js
var obj = {
  0: "asdfasdf",
  1: "asdfasfsdgfffd",
  length: 2,
};
console.log(obj);
// console.log(obj.0); // 0不是合法的标识符
// console.log(obj["0"]); // 属性表达式
// console.log(obj[0]); // js会自动将0转换为字符串"0"
```

```js
// var arr = [3, 6, 7, 82, 2, 1];
// arr[10] = "abc";
// var arr = [, , , "abc"];
//   var arr = [undefined, undefined, undefined, "abc"];//两者在下标上有本质区别
var arr = [, , ,]; //共有3项，最后一个,会被忽略，数组为了格式统一会忽略最后一个,号
var arr = new Array(100);//new Array()写一个数字的时候指的是数组的长度。一个以上指的才是数据值
console.log(arr);
```

平时几乎不会用到稀松数组。面试可能会用到

## 数组的常见操作

数组的操作特别多，现在学常见的

### 添加数组项

- 数组[长度] = 数据：向数组末尾添加一个数据

- 数组.push(数据)：向数组末尾添加一个数据(这是一个函数，数组里有很多函数，日后会详细讲函数)

- 数组.unshift(数据)：向数组起始位置添加一个数据，会导致数组每一项数据的下标向后移动

- 数组.splice(下标,0,添加的数据)：从指定下标位置开始，删除 0 个，然后在该位置插入添加的数据；如果下标超过范围，则按照范围的边界进行处理,一般不会造成稀松数组，比较安全

> push、unshift、splice 可以添加多个数据，依次写就好了用逗号分隔

### 删除数据

- delete 数据[下标]：这种做法不会导致数组的其他属性length等发生变化；因此，该做法会导致产生稀松数组，不推荐使用

- 数组.pop()：删除数组的最后一项，该表达式返回最后一项的数据

- 数组.shift()：删除数组的第一项，该表达式返回第一项的数据

- 数组.splice(下标,删除的数量,添加的数据)：从指定下标位置开始，删除指定数量，然后在该位置插入添加的数据；如果下标超过范围，则按照范围的边界进行处理；返回一个新数组，该数组记录被删除的数据、拼接的意思

### 其他操作

- 数组.slice(起始位置下标,结束位置下标)：将起始位置到结束位置之间的数据拿出来，得到一个新的数组，该函数不会改变原数组；注意：结束下标取不到、切片的意思

下标可以取负数，如果是负数，则从数组的末尾开始计算(从右向左选取)

如果不写结束下标，则直接取到末尾

- 数组清空

1. 数组.splice(0,数组.length);
2. 数组.length = 0;

- 查找数组中某一项的下标

数组.indexOf(数据)

从数组中依次查找对应的数据，查找时使用严格相等进行比较。找到第一个匹配的下标，返回；如果没有找到，则返回-1

若有第二个参数表示从哪个下标开始查找

数组.lastIndexOf(数据)

功能和 indexOf 类似，只是查找的是最后一个匹配的下标

- 数组.fill

数据.fill(数据)：将数组的所有项，填充为指定的数据

数组.fill(数据,开始下标)：将数组从开始下标开始，到数组的末尾，填充为指定的数据

数组.fill(数据,开始下标,结束下标)：将数组从开始下标起，到数组的结束下标(取不到)，填充为指定的数据

```js
//创建一个长度为100的数组，给数组的每一项赋值为"abc"
var arr = new Array(100);
//   for (var i = 0; i < arr.length; i++) {
//     arr[i] = "abc";
//   } //使用for-in循环实现不了这个效果，因为new Array(100)创建的是稀松数组

//用arr.fill()方法也能实现这个效果。将数组的所有项填充为指定的数据
arr.fill("abc", 3, 5);
console.log(arr);
```

## 语法补充

### in 关键字

判断某个属性在对象中是否存在

属性名(一定是字符串类型） in 对象

### for-in 有时也叫foreach 循环

```js
for (var 属性名prop/key/item in 对象) {
  //循环体
}
```

取出对象的所有属性名，每次循环将其中一个属性名赋值给变量 prop，运行循环体

```js
//   var obj = {
//     a: 1,
//     b: 2,
//     c: "fsfs",
//   };
//   for (var prop in obj) {
//     console.log(prop);
//   }
//利用该特点可以实现数组的遍历（将数组的每一项依次拿出来）
var arr = ["abc", "bcd", , , , "234", 54, 2, 1];
for (var index in arr) {
  console.log(index, typeof index, arr[index]); //length属性名有做特殊处理，所以不会循环到
}
for (var i = 0; i < arr.length; i++) {
  console.log(arr[i]);
}
//for循环和for-in循环在遍历数组时最大的区别是稀松数组的处理
```
- for循环和for-in循环的区别主要是稀松数组(for取到undefind，但for-in取不到)
