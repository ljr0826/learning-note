# 比较运算符

大小比较 > < >= <= (常为数字类型的比较)
相等比较 == != === !==(可以是数字也可以是其他类型)

**比较运算符的返回类型：boolean**

**算术运算符的优先级高于比较运算符**

`console.log(2 + 3 >= 5);`

## 大小比较

### 细节

1. 两个字符串比较大小，比较的是字符串的字符编码。（计算机无法识别文字，只能识别数字。ASCII码对照

```js
console.log(2 + 3 >= 5);
console.log("AB" > "AC"); //先比较第一个编码，若相同再比较第二个
console.log("11" > "2"); //false，一个一个比较；第一个如果不相等结果直接就出来了。和几位没有关系
console.log("11" > "1"); //true
```

2. 如果有一边不是字符串，并且两个都是原始类型，将他们都转换为数字进行比较

"1" -> 1
" " -> 0;
" a" -> NaN;

- NaN 与任何数字比较，得到的结果都是 false
- Infinity 比任何数字都大
- -Infinity 比任何数字都小

`console.log(null > -1);`
`console.log(undefined > 0)`

3. 如果其中一个是对象，将对象转化为原始类型后，按照规则 1、2 进行比较

> 目前，对象转化为原始类型后，是字符串"[object Object]"

## 相等比较

### ==和!=(相等比较和不相等比较)

==：比较两个数据是否相等
!=：比较两个数据是否不相等

### 细节

1. 两端的类型相同，直接比较两个数据本身是否相同（两个对象比较的是地址）
2. 两端的类型不同时：

1) null 和 undefined，他们之间相等，和其他原始类型比较则不相等
```js
console.log(null == undefined); //true
console.log(null >= 0); //true
console.log(null < 0); //false
console.log(null == 0); //false
console.log(undefined == 0); //false
```
2) 其他原始类型，比较时先转化为数字，再进行比较
3) NaN 与任何数字比较，都是 false，包括它本身
4) Infinity 和-Infinity，自身和自身相等，和其他数字比较都不相等
5) 对象相比较时，要先转化为原始类型后，再进行比较

**由于相等和不相等比较，对于不同类型的数据比较违反直觉，因此，通常我们不使用这种比较方式，而是使用更加接近直觉的严格相等和严格不相等比较**

### === 和 !==(严格相等和严格不相等)

===：两端的数据和类型必须相同

!==：两端的数据和类型不相同

1. 两端类型相同，规则和相等比较一致，直接比较即可

`console.log(NaN === NaN);//false`
`console.log(+0 === -0);//true` 

2. 两端类型不同，直接为 false

数字规则：

1. NaN 与任何数字比较，都是 false，包括自身
2. Infinity 和-Infinity，自身和自身相等，和其他数字比较都不相等
3. +0与-0相等
