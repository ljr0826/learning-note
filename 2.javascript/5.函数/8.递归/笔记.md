# 递归

- 斐波那契数列.html
- 阶乘.html

递归：在函数内部直接或间接调用自身（没有任何的js魔法，）

避免无限递归，

- 无限递归 VS 死循环

1. 死循环不会报错，也不会导致执行栈溢出
2. 无限递归会导致执行栈溢出，会报错

## 执行栈（进阶部分会详细学习执行上下文）

无论任何代码的执行都必须有一个执行环境，执行环境为代码的执行提供支持

执行环境是放到执行栈中的

- 在执行栈中，始终执行的都是栈的最顶部的执行环境

每个函数的调用都需要创建一个函数的执行环境，函数调用结束，执行环境销毁即：

> 函数调用-->创建函数执行环境-->调用结束-->销毁环境

执行栈有相对固定的大小，如果执行环境太多，执行栈无法容纳会报错

## 尾递归

如果一个函数最后一条语句是调用函数，并且调用函数不是表达式的一部分，则该语句称为尾调用，如果尾调用是调用自身函数，则称为尾递归

某些语言或执行环境会对尾调用进行优化，他们会立即销毁当前函数，避免执行栈空间被占用

遗憾的是：在浏览器执行环境中，尾调用没有优化。但在 node.js 环境中有优化

```js
//优化
//n的阶乘 n!
//total表示累乘的结果
function fhelper(n, total) {
  if (n === 1) {
    return total;
  }
  return fhelper(n - 1, n * total);
}

function f(n) {//辅助函数
  return fhelper(n, 1);
}

console.log(f(5)); 
```


