# 作用域链(解释一个闭包现象)

本节课的知识建立在执行上下文的基础上，解释闭包现象。
面试题和例题很重要，深度理解。课程上有图片

1. 变量对象VO (函数调用产生)中包含一个额外的属性，该属性指向创建该 VO 的函数本身（即调用的函数本身）
   1. 函数调用几次就产生几个VO。所以函数和VO不是一一对应的关系

2. 每个函数在创建/定义/声明时，会有一个隐藏属性`[[scope]]`，存放地址；它指向创建该函数时的变量对象，（即当前的变量对象 AO）
   1. 所有函数定义、运行都是在执行上下文中
   2. 正是因为这个隐藏属性。才可以说函数内部可以使用外部环境的变量

3. 当访问一个变量时，会先查找自身 VO 是否存在，如果不存在，则依次查找`[[scope]]`属性（使用最近的变量）

某些浏览器会优化作用域链，声明函数的`[[scope]]`中仅保留需要用到的数据

> 创建函数时形成闭包，而非调用时！(若形成闭包，寻找数据时，找到函数定义时的数据)
> 即寻找函数定义时的作用域，而不是函数运行时的作用域。见test3.html

```js
var g = 0;
function A() {
  var a = 1;
  function B() {
    var b = 2;
    var C = function () {
      var c = 3;
      console.log(c, b, a, g);
    };
    C();
  }
  B();
}
A();
//作用域链见黑线
```
<img src="./作用域链.jpg" alt="" />

```js
function A() {
  var count = 0;
  return function () {
    count++;
    console.log(count);
  }; //这个是函数表达式，而不是函数字面量
}
var test = A();
//js中有垃圾回收器。A的执行上下文出栈。但是A的VO由于找得到（通过函数的[[scrop]]）还在
//即由于函数执行完成。该函数的执行上下文出栈。但是由于函数执行时内部定义的函数的[[scope]]指向当前VO所以将执行上下文中的VO下来
//这个特点在js的某种应用中很常见
//闭包：广义上说就是函数内部可以使用外部函数的变量。狭义上说就是由于函数声明时的属性[[scope]]指向当前VO所以导致VO中的局部变量保存了下来
//按照作用域链改变变量的值是可以的
test(); //1
test(); //2
test(); //3
console.log(count); //报错
```
```js
//考法二：
console.time();
for (var i = 0; i < 3; i++) {
  (function (i) {
    setTimeout(function () {
      console.log(i);
    }, 1000); //function(){}作为setTimeout的第一个参数是在全局环境中定义的。所以他的[[scope]]指向全局GO
  })(i); //用立即执行函数可以解决这个问题。这样的话计时器的函数参数的[[scope]]指向的是IIFE的VO
}
console.timeEnd();
```