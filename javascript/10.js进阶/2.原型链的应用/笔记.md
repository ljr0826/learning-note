# 原型链的应用

## 基础方法

W3C 不推荐直接使用系统成员`__proto__`

**Object.getPrototypeOf(对象)**：获取对象的隐式原型

```js
var obj = {};
Object.getPrototypeOf(obj) === obj.__proto__;
```

**Object.prototype.isPrototypeOf(对象)**：判断当前对象(this -> Object.prototype)是否在指定对象的原型链上

```js
var o = {};
o.isPrototypeOf(obj); //flase
Object.getPrototypeOf(obj).isPrototypeOf(o); //true
```

**对象 instanceof 函数**：判断函数的原型是否在对象的原型链上

```js
Object.prototype.isPrototypeOf(obj) === obj instanceof Object;
```

**Object.create(对象)**：创建一个新对象，其隐式原型指向指定的对象

```js
(var obj = Object.create(Object.prototype) === (obj = {});
```

注：由于骚操作`var obj = Object.create(null)`导致所有的对象原型链最终都会指向 Object.prototype 这句话是错误的

**Object.prototype.hasOwnProperty(属性名)**：判断一个对象自身是否拥有某个属性

## 应用

**类数组转换为真数组**

`Array.prototype.slice.call(类数组)`取代`[].slice.call(类数组)`

**实现继承**

默认情况下，所有构造函数的父类都是 Object(自定义函数继承自 Object )

圣杯模式
