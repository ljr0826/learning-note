# 更好的 unicode 支持

早期，由于储存空间宝贵，unicode 使用 16 位二进制来存储文字。我们将一个 16 位的二进制编码叫做一个码元(code unit)

后来，由于技术的发展，unicode 对文字编码进行了扩展，将某些文字扩展到了 32 位(占用两个码元)，并且将某个文字对应的二进制数字叫做码点(code point)

ES6 为了解决这个困扰，为字符串提供了方法：codePointAt(),根据字符串码元的位置得到码点

同时 ES6 为正则表达式添加了一个 flag： u，若添加了该配置，则匹配时使用码点匹配

```js
const text = "吉";
console.log("字符串长度:", text.length);
console.log("使用正则表达式测试:", /^.$/u.test(text));
```

```js
//判断字符串char是32位还是16位
function is32bit(char, i) {
  //如果码点大于了16位二进制的最大值，则其是32位的
  return char.codePointAt(i) > 0xffff;
}
console.log("吉是否是32位的：", is32bit(text));
```

```js
//得到一个字符串码点的真实长度
function getLengthOfCodePoint(str) {
  let len = 0;
  for (let i = 0; i < str.length; i++) {
    //i在索引码元
    if (is32bit(str, i)) {
      //当前字符串在i这个位置，占用了两个码元
      i++;
    }
    len++;
  }
  return len;
}
console.log(getLengthOfCodePoint("ab即吉c"));
```
